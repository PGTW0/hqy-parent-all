# Seata

seata 一款开源的分布式事务解决方案。



## Seata的整体架构

* **TC(Transaction Coordinator) 事务协调者**

  维护全局和分支事务的状态，驱动全局事务提交或回滚。

* **TM(Transaction Manager) 事务管理器**

   定义全局事务的范围：开始全局事务、提交或回滚全局事务。

* **RM（Resource Manager）资源管理器**

  管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。

* **事务回话信息存储**

  非必须角色，理论上可以不引入额外组件。

  事务会话信息存储方式有：file本地文件(不支持HA)，db数据库|redis(支持HA) 但从生产实践角度来看，这个组件也是必须的

* **注册中心**

  非必须角色，理论上可以不引入额外组件。

  默认file，支持file 、nacos 、eureka、redis、zk、consul、etcd3、sofa、custom

* **配置中心**

  非必须角色，理论上可以不引入额外组件。

  默认file，支持file、nacos 、apollo、zk、consul、etcd3、custom




## AT模式

AT模式需要保证每个业务库，都有一张`undo_log`表，保存着业务数据执行前和执行后的镜像数据。

### 1、前提条件

- 基于支持本地 ACID 事务的关系型数据库。
- Java 应用，通过 JDBC 访问数据库。

### 2、整体机制

两阶段提交协议的演变：

- 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
- 二阶段：
  - 提交异步化，非常快速地完成。
  - 回滚通过一阶段的回滚日志进行反向补偿。

### 3、读写隔离的实现

#### 写隔离

- 一阶段本地事务提交前，需要确保先拿到 **全局锁** 。
- 拿不到 **全局锁** ，不能提交本地事务。
- 拿 **全局锁** 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。

#### 读隔离

在数据库本地事务隔离级别 **读已提交（Read Committed）** 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 **读未提交（Read Uncommitted）** 。

SELECT FOR UPDATE 语句的执行会申请 **全局锁** ，如果 **全局锁** 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 **全局锁** 拿到，即读取的相关数据是 **已提交** 的，才返回。

出于总体性能上的考虑，Seata 目前的方案并没有对所有 SELECT 语句都进行代理，仅针对 FOR UPDATE 的 SELECT 语句。